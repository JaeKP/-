# 그래프 최단 거리

## 1. 간선완화(Edge Relxation)

> 가중치가 있을 때 너비우선 탐색을 일반적으로  진행하면 안된다. 
> 이미 방문했던 정점이더라고 더 짧은 경로를 발견하면 그걸로 값을 갱신해야한다. 
>
>  즉, 다시 방문을 해야한다. (q에 추가)  => 그래서 방문표시가 의미가 없어진다.

<br>

### 1) 핵심 개념

**출발점에서 v(정점)까지의 가장 짧은 거리 정보를 D[v]에 저장한다.** 

더 짧은 경로를 찾으면 수정해서 전파를 해야 한다. 

만약 더 좋은 경로가 아니라면 q에 추가를 하지 않는다. 

<br>

**D 배열을 아주 큰 값으로 설정한다.(default)**

- 최대, 최솟값을 비교할 때를 생각하면 된다.
- 해당 정점에서 어떠한 경로도 찾지 못했다. 
- 출발점의 D값은 0으로 초기화 한다.
- 원래는 아주 큰 값이였는데 값이 점점 줄어들다가 최적해에 도달한다. (간선 완화!)

<br>

```python
# u => v ( u에서 v로 간다고 가정)

if D[v] > D[u] + w:  # w: 간선의 가중치
    D[v] = D[u] + w  # 더 짧은 경로로 수정!
```

<br>

### 2) 구현

가중치가 부여된 유향그래프에서 최단거리를 구해라.

- 인접 행렬: 가중치로 저장한다. 
- 인접 리스트: 정점과 가중치값을 튜플이나 리스트로 묶어서 저장한다.  

<br>

-  브루트 포스

```python
for tc in range(1, int(input()) + 1):
    N, E = map(int, input().split())  # N은 마지막 정점의 번호, E는 간선의 개수이다.
    G = [[] for _ in range(N + 1)]    # 정점 0번부터 N번까지의 인접리스트 생성한다. 
    for _ in range(E):
        u, v, w = map(int, input().split()) # u: 구간 시작지점, v: 구간 끝지점, w: 구간 거리 (가중치)
        # 가중치 유향 그래프
        G[u].append((v, w)) # G[시작 정점 번호] = (도착 정점 번호, 가중치)
    
    # 거리를 저장하는 배열
    D =[0xffffff] * (N + 1)
    D[0] = 0         # 출발점 설정
    
    # 모든 간선에 대해서 (간선 완화)
    while True:
        flag = True
        for u in range(0, N + 1): # 모든 정점들을 순회
            for v, w in G[u]:     # 정점의 인접 정점을 순회
                if D[v] > D[u] + w:
                    D[v] = D[u] + w
                    flag = False
        # for문을 통해서 D 값의 변경이 없다면 최적해를 찾은 것이다. 
        if flag:
            break
    print(f'#{tc} {D[N]}')
```

<br>

- BFS

```python
for tc in range(1, int(input()) + 1):
    N, E = map(int, input().split())  # N은 마지막 정점의 번호, E는 간선의 개수이다.
    G = [[] for _ in range(N + 1)]    # 정점 0번부터 N번까지의 인접리스트 생성한다. 
    for _ in range(E):
        u, v, w = map(int, input().split()) # u: 구간 시작지점, v: 구간 끝지점, w: 구간 거리 (가중치)
        # 가중치 유향 그래프
        G[u].append((v, w)) # G[시작 정점 번호] = (도착 정점 번호, 가중치)
    
    # 거리를 저장하는 배열
    D =[0xffffff] * (N + 1)
    D[0] = 0         # 출발점 설정
    Q = [0]
    
    # 모든 간선에 대해서 (간선 완화)
    while Q:
        u = Q.pop(0)
        for v, w in G[u]:
            if D[v] > D[u] + w:
                D[v] = D[u] + w
                Q.append(v)
    print(f'#{tc} {D[N]}')
```

<br>

## 2. 다익스트라 알고리즘

