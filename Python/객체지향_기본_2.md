# 객체지향_ 기본_2

  ## 상속

> 클래스간의 상속은 부모 클래스의 속성과 메서드를 자식 클래스에서 직접 접근하고 사용가능하다는 것을 의미한다. 
>
> 즉, 자식 클래스에서는 부모클래의 속성과 메서드를 따로 기입하지 않아도 접근 및 사용이 가능하다. (코드 재사용성이 좋아진다.)

```python
class Food(): #부모클래스
    
    def __init__(self, name, price):
        self.name = name
        self.price = price
        
    def evaluate(self, taste):
        return f'{taste}'
        
class Chicken(Food): #자식 클래스
    pass

pizza = Food('파인애플피자', 20000)
bhc = Chicken('뿌링클', 18000) #bhc = Chicken()는 생성이 불가하다. 부모클래스에서 정의한 속성을 기입하지 않으면 자식클래스의 인스턴스 생성불가!

print(pizza.evaluate('Bad')) # Bad
print(bhc.evaluate('Good')) # Good 자동으로 부모클래스의 메서드를 사용 가능하다. 

print(bhc.price) # 18000 

```

<br>

- 상속여부를 확인하는 함수로 `issubclass(자식, 부모)`가 있다.
- 클래스임을 확인하는 함수인 `isinstance(인스턴스, 클래스*)`와 헷갈리지 않도록 조심!
  `isinstance`의 매개변수 중 하나인  클래스는 인스턴스를 생성한 클래스, 인스턴스를 생성한 클래스의 부모클래스 모두 포함한다. 

```python
class Food: #부모클래스
    
    def __init__(self, name, price):
        self.name = name
        self.price = price
        
    def evaluate(self, taste):
        return f'{taste}'
        
class Chicken(Food): #자식 클래스
    pass


pizza = Food('파인애플피자', 20000)
bhc = Chicken('뿌링클', 18000)

print(issubclass(Chicken, Food)) # True
print(issubclass(bhc, chicken)) # 오류발생. 클래스가 아니다. 
print(isinstance(bhc, Food)) # True 

---
print(issubclass(int,int)) # True
print(issubclass(float,int)) # False
print(issubclass(bool,int)) # True
```

<br>

### 메서드 오버라이딩

> 부모클래스의 속성 및 메서드를 다시 정의하는 것을 의미한다. 
>
> 일반적으로 메서드의 이름은 같지만 기능을 약간 수정해야할 때 사용한다. 

```python
class Food: #부모클래스
    
    def __init__(self, name, price):
        self.name = name
        self.price = price
        
    def evaluate(self, taste):
        return f'{taste}'
        
class Chicken(Food): #자식 클래스
    
    def evaluate(self, taste): # 오버라이딩
        return f'이 치킨은 {taste}~!'
    
pizza = Food('파인애플피자', 20000)
bhc = Chicken('뿌링클', 18000)

print(pizza.evaluate('BAD')) # BAD 
print(bhc.evaluate('GOOD')) # 이 치킨은 GOOD~! // 오버라이딩을 하면 이제 부모의 evaluate()메서드를 사용하지 못한다는 단점이 있다. 
```

<br>

- 만약, 부모클래스의 메서드도 호출하고 자식클래스의 메서드의 내용을 함께 호출하고 싶다면 `super()`사용하면 된다.
  자식 클래스에서 부모클래스의 메서드를 호출해서 사용할 수 있다. 

```python
class Food: #부모클래스
    
    def __init__(self, name, price):
        self.name = name
        self.price = price
        
    def evaluate(self, taste):
        return f'{taste}'
        
class Chicken(Food): #자식 클래스
    
    def evaluate(self, taste, star):
        return super().evaluate(taste) + f'\n별점은 {star}점 입니다' # 기존의 부모 메서드를 활용하면서 새로운 기능 추가. (부분 재정의)
       
    
pizza = Food('파인애플피자', 20000)
bhc = Chicken('뿌링클', 18000)

print(pizza.evaluate('BAD'))  # BAD
print(bhc.evaluate('GOOD', 5))  # GOOD \n 별점은 5점 입니다 
```

<br>

- 슈퍼함수 `super()`는 속성에서도 활용 가능하다. 

```python
class Food: #부모클래스
    
    def __init__(self, name, price):
        self.name = name
        self.price = price
        
    def evaluate(self, taste):
        return f'{taste}'
        
class Chicken(Food): #자식 클래스
    
    def __init__(self, name, price, rank, phone):
        super().__init__ (name, price) #super()로 부모클래스의 __init__메서드 호출
        self.rank = rank
        self.phone = phone
        

        
pizza = Food('파인애플피자', 20000)
bhc = Chicken('뿌링클', 18000, 5, '02-123-456')

print(bhc.rank) # 5
print(bhc.price) # 18000
```

<br>

### 다중 상속

> 여러 부모클래스로 부터 상속을 받는 자녀클래스를 만들 수 있다. 

```python
class Chicken: #부모클래스 1
    brand = 'bhc'
    
    def __init__(self, name, price):
        self.name = name
        self.price = price
        
    def evaluate(self, taste):
        return f'{taste}'
    
class Pizza: # 부모클래스 2
    brand = 'pizzahut'
    
    def __init__(self, name, price):
        self.name = name
        self.price = price
        
    def evaluate(self, star):
        return f'평점은 {star}점이다.'
    

class ChickenWing(Chicken, Pizza):  #Chicken이 우선순위 부모클래스 이다.
    pass

cw = ChickenWing('핫윙', 5000)

print(cw.brand) # bhc // Chicken 클래스의 클래스 변수값을 따른다.
print(cw.evaluate('GOOD')) # GOOD // Chicken 클래스의 메서드를 따른다.
```

<br>

- 부모클래스를 탐색할 수 있는 함수 `mro()`

```python
class Chicken: #부모클래스 1
    brand = 'bhc'
    
    def __init__(self, name, price):
        self.name = name
        self.price = price
        
    def evaluate(self, taste):
        return f'{taste}'
    
class Pizza: # 부모클래스 2
    brand = 'pizzahut'
    
    def __init__(self, name, price):
        self.name = name
        self.price = price
        
    def evaluate(self, star):
        return f'평점은 {star}점이다.'
    

class ChickenWing(Chicken, Pizza):  #Chicken이 우선순위 부모클래스 이다.
    pass


print(ChickenWing.mro()) # [<class '__main__.ChickenWing'>, <class '__main__.Chicken'>, <class '__main__.Pizza'>, <class 'object'>]
```

<br>

## getter메서드와 setter메서드

### 접근 제어자

- public: 일반적인 클래스로 외부로부터 **모든 접근**이 가능하다. 
- protected: `_ 메사드` 혹은 `_속성`으로 **자기클래스 혹은 자식클래스**에서만 접근이 가능하다.(하지만 강제성은 없다.)
- private: `__메서드` 혹은 `__속성`으로 **자기클래스**에서만 접근이 가능하다. 

```python
class Food: #부모클래스
    
    def __init__(self, name, price):
        self.__name = name
        self.price = price
        
    def evaluate(self, taste):
        return f'{taste}'

    def my_name(self):
        return self.__name
        
class Chicken(Food): #자식 클래스
    pass

        
pizza = Food('파인애플피자', 20000) # 접근이 불가능하다고 pizza = Food(20000)로는 생성이 불가능하다. 
bhc = Chicken('뿌링클', 18000) 

print(pizza.name) # 클래스 외부이기 때문에 접근이 불가능하다. 
print(bhc.name) # 클래스 외부이기 때문에 접근이 불가능하다. 

print(pizza.my_name()) # 파인애플피자 // 이렇게는 접근할 수 있다.
print(bhc.my_name()) # 뿌링클 // 이렇게는 접근할 수 있다.
```

<br>

### getter메서드와 setter메서드



